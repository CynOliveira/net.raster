% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/computeModules.spat.R
\name{computeModules.spat}
\alias{computeModules.spat}
\title{Newman's modularity for raster data}
\usage{
computeModules.spat(
  rh,
  rl,
  web,
  method = "Beckett",
  deep = FALSE,
  deleteOriginalFiles = TRUE,
  steps = 1e+06,
  tolerance = 1e-10,
  experimental = FALSE,
  forceLPA = FALSE
)
}
\arguments{
\item{rh}{SpatRaster. A raster (stack) containing presence-absence data (0 or 1)
for the higher level set of species.}

\item{rl}{A SpatRaster. A raster (stack) containing presence-absence data (0 or 1)
for the lower level set of species.}

\item{web}{Matrix. A weighted bipartite network matrix, binary (o or 1) or
not, where the lower level species (e.g. plants) are rows and higher level (e.g.
frugivores or pollinators)species are columns. The layers (species) of each
raster must be sorted according to the bipartite network order!}

\item{method}{Choice between the algorithm(s) provided by Stephen Beckett (2016) or Dormann & Strauss (2016) (\option{method="DormannStrauss"}). Defaults to the much faster and in the majority of cases better algorithm of Beckett. (Note the optional argument \option{forceLPA} to use his slightly inferior but even faster pure LPA algorithm.)}

\item{deep}{
If \code{deep} is set to FALSE (default), a flat clustering is computed, otherwise submodules are identified recursively within modules. Works only with \option{method="DormannnStrauss"}.
}

\item{deleteOriginalFiles}{
If \code{deleteOriginalFiles} is set to TRUE (default), the files mentioned above in the description are deleted from the hard drive disk, otherwise not. Applies only to \option{method="DormannnStrauss"}.
}

\item{steps}{
\code{steps} is the number of steps after which the computation of modules stops if no better division into modules than the current one can be found. Applies only to \option{method="DormannnStrauss"}.
}

\item{tolerance}{How small should the difference between MCMC-swap results be? At some point computer precision fluctuations make the algorithm fail to converge, which is why we choose a (very low) defaults of 1E-10. Applies only to \option{method="DormannnStrauss"}.}

\item{experimental}{Logical; using an undescribed and untested version for which no detail is available? (We suggest: not yet.) Applies only to \option{method="DormannnStrauss"}.}

\item{forceLPA}{Logical; should the even faster pure LPA-algorithm of Beckett be used? DIRT-LPA, the default, is less likely to get trapped in a local minimum, but is slightly slower. Defaults to FALSE.  Applies only to \option{method="Beckett"}.}
}
\value{
Spatraster with the spatial Newman's modularity
}
\description{
Calculates modules by applying Newman's modularity measure to a
spatial weighted bipartite network. Users must choose between the algorithms
of Stephen Beckett (2016) or Dormann & Strauss (2016) (method="DormannStrauss").
The default is the Beckett algorithm, which is faster and generally better.
View more about it at  \link[bipartite]{computeModules}
}
\details{
Note that if a network is very small, with few nodes or links, it may be
impossible to calculate the metric or calculated result may be unreliable.
As the calculation is made with the subnet of each pixel, even in cases
like this, it can be possible to visualize the spatialized metric on a
macroecological scale.
}
\examples{
\dontrun{
library(terra)
library(bipartite)
# load bipartite network and the raster stacks of higher level and lower level
species
bipnet <- read.csv(system.file("extdata", "bipnet.csv",
package="net.raster"), row.names=1, sep= ";" )#change separator if necessary
rasth <- rast(system.file("extdata", "rasth.tif",
package="net.raster"))
rastl <- rast(system.file("extdata", "rastl.tif",
package="net.raster"))
# computing Newman's modularity with faster method, Beckett algorithm (default)
compMod <- computeModules.spat (rasth, rastl, bipnet)
plot(compMod)
# calculating Newman's modularity with alternative method
compModDS <- computeModules.spat (rasth, rastl, bipnet, method="DormannStrauss")
plot(compModDS)

}
}
\references{
Rouven Strauss, with fixes by Carsten Dormann and Tobias Hegemann;
modified to accommodate Beckett’s algorithm by Carsten Dormann ("bipartite"
package)
Beckett, S.J. 2016 Improved community detection in weighted
bipartite networks. Royal Society open science 3, 140536.
Dormann, C. F., and R. Strauß. 2014. Detecting modules in quantitative
bipartite networks:the QuanBiMo algorithm. Methods in Ecology & Evolution 5
90–98 (and arXiv q-bio.QM 1304.3218.)
Liu X. & Murata T. 2010. An Efficient Algorithm for Optimizing Bipartite
Modularity in Bipartite Networks. Journal of Advanced Computational
Intelligence and Intelligent Informatics (JACIII) 14408–415.
Newman M.E.J. 2004. Physical Review E 70 056131
Newman, M.E.J. 2006. Modularity and community structure in networks.
Proceedings of the National Academy of Sciences of the United States of
America, 103, 8577—8582.
}
\seealso{
\code{\link{prep.web}}
}
\author{
Neander Marcel Heming and Cynthia Valéria Oliveira
}
